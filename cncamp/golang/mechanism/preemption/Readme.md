Preemption Mechanism
---

- 抢占式调度： 避免某个协程长时间运行，而阻碍其他协程被调度的机制。

- 时间片轮转的效果：调度器会监听每个协程的“执行时间”，一旦执行时间过长，且有其他协程在等待时，会把此协程暂停，转而调度等待的协程。

- Go 1.14 之前，抢占式调度机制是有一定局限性的 - 在函数调用间隙检查协程是否被抢占，如果协程没有函数调用，则会无限期地占用执行权，如无函数调用的无限循环

   ```go
   func main() {
        runtime.GOMAXPROCS(1)
        
        go func() {
            // 类 for {} 无限循环 <- 无函数调用的无限循环
            println("for {}")
            select {} // 永远阻塞
        }()
        
        time.Sleep(1 * time.Second) // 系统调用，出让执行权给上面的协程
        println("Done")
   }
   ```
  
- Go 1.14 中，调度器引入了`基于信号的抢占机制`，才解决了 `如果协程没有函数调用，则会无限期地占用执行权` 的问题。