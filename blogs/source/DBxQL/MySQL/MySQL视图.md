# MySQL 视图

## 数据库对象

|对象|描述|
| :--- | :--- |
|表 table|表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录|
|数据字典|系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护。|
|约束 CONSTRAINT|执行数据校验的规则，用于保护数据完整性的规则|
|视图 VIEW|一个或多个数据表里的数据的逻辑显示，视图并不存储数据|
|索引 INDEX|用于提高查询性能，相当于已的目录|
|存储过程 PROCEDURE|用于完成一次完整的业务处理，没有返回值，但可通过传出参数，将多个值传给调用环境|
|存储函数 FUNCTION|用于完成一次特定的计算，具有一个返回值|
|触发器 TRIGGER|相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理|

> 三级模式两级映射：存储文件-->基本表-->视图；内模式-->模式-->外模式；

## 视图

视图是一种虚拟表，建立在已有表的基础上，依赖于这些基表，整合一张或多张表数据，本身是不具体数据的，占用很少的内存空间。
可以将视图理解为存储起来的select语句，不会保存数据；视图的创建、删除只影响视图本身，不影响对应的基表；数据真正保存在数据表中，当对视图中的数据进行增加、删除和修改时，数据表中的数据会相应地发生变化。
使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变。
通过情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以把经常查询的结果集放到虚拟表中，提升使用效率。

### 作用

视图一方面可以使用表的一部分，而不是所有的表，另一方面可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，只能查看部分数据，而某些特殊的数据，比如采购的价格，则不会提供；人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中，则不提供这个字段。
可以对经常使用的查询定义一个视图，使用户不必为同样的查询操作指定条件；通过视图，用户只能查询和修改指定的数据；视图可以屏蔽原有表结构变化带来的影响。

### 使用

```mysql
CREATE [OR REPLACE]
[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW 视图名称 [(字段列表)]
AS 查询语句
[WITH [CASCADED|LOCAL] CHECK OPTION];

-- 精简版
CREATE VIEW 视图名称
AS 查询语句;

-- 查询
SELECT *
FROM 示图名称;

-- 查看数据库的表对象、视图对象：
show tables;

-- 查看视图的详细定义信息：
show create table view_name;

-- 查看视图的结构
desc view_name;

-- 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）
--  执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表
SHOW TABLE STATUS LIKE '视图名称'\G;
```

```mysql
-- 单表创建视图
create view emp_vu
as
select employee_id,last_name,salary from employees where department_id=80;

create view emp_year_salary(ename,year_salary)
as
select ename,salary*12*(1+IFNULL(comission_pct,0)) from t_employee;

-- 联合多表创建视图
create view emp_view
as
select e.employee_id emp_id,e.last_name name,d.department_name from employees e,departments d where e.department_id = d.department_id;
```

在SQL查询语句的基础上封装了视图，基于SQL语句的结果集形成一张虚拟表；如果在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和select语句中的字段列表一致，如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。

```mysql
-- 支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。
update view_name
set salary=11
where emp_id=11;
```

注：要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。当视图定义出现如下情况，视图不支持更新操作：
1. 在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；
2. 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；
3. 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作；
4. 在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；
5. 在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；
6. 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；
7. 视图定义基于一个不可更新视图；
8. 常量视图不可以进行更新

>  虽然在一定条件下可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。

#### 修改、删除

- 使用CREATE OR REPLACE VIEW 子句修改视图：
    
  ```mysql
  CREATE OR REPLACE VIEW emp_vu
  (id_number, name, sal, department_id)
  AS
  SELECT employee_id, first_name || ' ' || last_name, salary, department_id
  FROM employees
  WHERE department_id = 80;

  desc emp_vu;
  ```

- ALTER VIEW：
    
  ```mysql
  ALTER VIEW 视图名称
  AS
  查询语句
  ```

   删除视图只是删除视图的定义，并不会删除基表的数据。

- 删除视图：
  
  ```mysql
  drop view if exists view_name;
  ```

  注：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。此时，视图c需要手动删除或修改，否则影响使用。

## 总结

### 优点

1. 操作简单

  将经常使用的查询操作定义为视图，可以不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了对数据库的操作。

2. 减少数据冗余

  **视图跟实际数据表不一样，它存储的是查询语句**。所以，在使用的时候，要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。

3. 数据安全

  MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表，用户不需要查询数据表，可以直接通过视图获取数据表中的信息。

4. 适应灵活多变的需求

  当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。

5. 能够分解复杂的查询逻辑

  数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。

### 缺点

- 如果在实际数据表的基础上创建了视图，实际数据表的结构变更了，需要及时对相关的视图进行相应的维护。
- 特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。
- 因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。



